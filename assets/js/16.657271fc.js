(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{560:function(t,a,s){t.exports=s.p+"assets/img/webpackOptSourceMap.b6b346ee.png"},601:function(t,a,s){"use strict";s.r(a);var n=s(4),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"webpack实战-性能优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webpack实战-性能优化"}},[t._v("#")]),t._v(" webpack实战——性能优化")]),t._v(" "),n("div",{staticClass:"custom-block danger"},[n("p",[n("strong",[t._v("文章转载请标明地址与出处！")])])]),t._v(" "),n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),n("p",[t._v("我们已经学习完了开发环境和成产环境的配置，接下来学习 webpack 的性能优化。从环境角度讲，性能优化分为开发环境性能优化和生产环境性能优化。对于开发环境，我们需要优化打包构建速度、优化代码调试。对于生产环境，我们需要优化打包构建速度、优化代码运行性能。")]),t._v(" "),n("h2",{attrs:{id:"hmr"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hmr"}},[t._v("#")]),t._v(" HMR")]),t._v(" "),n("p",[t._v("在之前我们搭建的开发环境中，由于配置了 devServer，所以当文件有修改时会重新编译。但是我们发现如果我只改动 css 文件，保存时 js 文件也一样会被重新编译。并且如果我们写若干个 js 模块内容并将其引入 index.js 文件中，当我修改其中一个模块的内容时，其他模块也会被重新编译。这就说明 devServer 更新时是全量编译的，这意味着以后项目变的非常大并且有非常多的模块时，我只改动其中一个模块后整个项目的模块都要重新编译，这样编译的速度会非常慢，使开发者的体验很差。而 HMR（hot module replacement）就可以帮助我们进行优化，使得我们修改一个模块时，只重新编译我们所修改的模块，而不是打包所有模块，极大提升构建速度。")]),t._v(" "),n("p",[t._v("HMR 的配置很简单，只需要在 devServer 配置项中添加 hot 配置即可。")]),t._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[t._v("module"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...此处省略其他配置")]),t._v("\n  devServer"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    contentBase"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__dirname"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"dist"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    compress"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    port"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("3000")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    open"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    hot"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("配置后我们发现，只有样式文件的 HMR 是生效的，这是因为 style-loader 内部实现了这个功能。 而 js 文件和 html 文件默认是不能使用 HMR 功能的，html 文件开启 devServer 后甚至无法热更新。解决 html 热更新需要以下配置：")]),t._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[t._v("module"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  entry"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./src/index.js"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./index.html'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...此处省略其他配置")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("我们将 index.html 文件加入了入口文件的配置，这样便能解决其热更新的问题。目前我们构建的是单页面应用，即只有一个 html 文件，所以不用而且没必要做 HMR 功能。我们只要解决 js 文件的 HMR 功能即可，需要修改 js 代码，添加支持 HMR 功能的代码。")]),t._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" print "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./print'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("module"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("hot"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  module"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("hot"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("accept")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'.print.js'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("print")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("这句代码的 module 是一个全局中的变量，并查看 module 中是否有 hot 属性，hot 属性默认为 undefined 或 false，一旦 module.hot 为 true，说明开启了 HMR 功能，这时候我们便运行里面的 HMR 功能代码。module.hot.accept() 方法会监听第一个参数传入文件的变化，一旦发生变化会执行第二个回调函数参数，其他模块不会重新打包构建。")]),t._v(" "),n("blockquote",[n("p",[t._v("注意：js 文件的 HMR 功能只需要处理非入口文件的其他文件。")])]),t._v(" "),n("h2",{attrs:{id:"source-map"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#source-map"}},[t._v("#")]),t._v(" source map")]),t._v(" "),n("p",[t._v("source map 是一种提供源代码到构建后代码映射的技术。如果构建后代码出错，由于代码已被打包，我们很难追踪出错代码的位置。而 source map 可以通过映射源代码到构建后的代码，使得可以追踪源代码错误。  开启 source mep 功能我们只需在 webpack.config.js 中添加配置：")]),t._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[t._v("module"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  devtool"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'source-map'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...此处省略其他配置")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("配置后我们进行编译，会发现 dist 目录下会多出映射文件。")]),t._v(" "),n("img",{staticStyle:{zoom:"60%"},attrs:{src:s(560),alt:"webpackOptSourceMap"}}),t._v(" "),n("p",[t._v("以上只是 source map 最基本的配置，它还有几个参数可配置，具体写法为 "),n("code",[t._v("[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map")]),t._v("。参数位置不可改变。")]),t._v(" "),n("p",[n("code",[t._v("source-map")]),t._v(" 为外部 source map，它通过 .map 内的映射信息将错误映射回源代码，所以这个配置可以提示错误代码的准确信息和源代码的错误位置。")]),t._v(" "),n("p",[n("code",[t._v("inline-source-map")]),t._v(" 为内联 source map，它不会生成映射文件，而映射信息变为 base64 后嵌入在对应 js 文件内部的结尾处，这种内联只生成一个内联映射信息。这个配置可以提示错误代码的准确信息和源代码的错误位置。")]),t._v(" "),n("p",[n("code",[t._v("hidden-source-map")]),t._v(" 为外部 source map，它会在外部生成一个以 .map 结尾的文件存放映射信息。这个配置可以提示错误代码的原因，但是没有错误的位置，而且不能追踪源代码的错误，只能提示到构建后代码的错误位置。")]),t._v(" "),n("p",[n("code",[t._v("eval-source-map")]),t._v(" 也为内联 source map，与 inline 不同的是，它会给每一个文件都生成对应的映射信息并放在 eval 函数内。这个配置可以提示错误代码的准确信息和源代码的错误位置。")]),t._v(" "),n("p",[n("code",[t._v("nosources-source-map")]),t._v(" 也会生成一个外部 source map。这个配置可以提示错误代码的准确信息，但是无法追踪源代码的错误位置。")]),t._v(" "),n("p",[n("code",[t._v("cheap-source-map")]),t._v(" 为外部 source map。这个配置可以提示错误代码的行信息和源代码的错误行位置，它只能精确到错误的行数，无法精确到列信息（column-mappings）。并且其不包含 loader 的 sourcemap（譬如 babel 的 sourcemap）。")]),t._v(" "),n("p",[n("code",[t._v("cheap-module-source-map")]),t._v(" 为外部 source map。。这个配置可以提示错误代码的行信息和源代码的错误行位置，它只能精确到错误的行数，无法精确到列信息（column-mappings）。同时 loader 的 sourcemap 也被简化为只包含对应行的。")]),t._v(" "),n("p",[t._v("总体而言，内联 source map 的构建速度比外部 source map 更快（eval 最快，eval > inline > cheap > ...），但是代码体积会变大。在开发环境下，我们需要考虑构建速度快以及调试友好，所以可以使用 "),n("code",[t._v("eval-cheap-module-source-map")]),t._v(" 或者 "),n("code",[t._v("eval-source-map")]),t._v("，而前端框架的脚手架一般默认使用的是 "),n("code",[t._v("eval-source-map")]),t._v("。在生产环境下，我们需要考虑源代码的隐藏、代码体积以及调试友好，所以不考虑内联 source map，而具体使用还需看使用场景需求。")]),t._v(" "),n("h2",{attrs:{id:"oneof"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#oneof"}},[t._v("#")]),t._v(" oneOf")]),t._v(" "),n("p",[t._v("在生成环境 webpack 的配置文件中，我们通常会配置很多 loader 来处理项目中的文件。随着文件与 loader 增多，有可能会出现一个文件被匹配多次的情况，这样会降低构建速度。oneOf 配置可以帮我们很好的处理：")]),t._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[t._v("module"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  module"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    rules"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        oneOf"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n          "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...只匹配一次的 loader 配置")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...其他loader配置")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...此处省略其他配置")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("配置在 oneOf 内的 loader 只会匹配一个，但是要注意不能有两个配置处理同一种类型文件。如果遇到需要处理两次的情况（比如处理 js 需要 eslint-loader 和 babel-loader），可以将其中一个配置（比如 js 的 eslint-loader）提取到 oneOf 的外面。")])])}),[],!1,null,null,null);a.default=e.exports}}]);